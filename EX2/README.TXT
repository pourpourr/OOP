ΓΕΩΡΓΙΟΣ ΠΟΥΡΝΑΡΑΣ ΑΜ: 1115201800162

Αυτό είναι το αρχείο που θα επεξηγηθεί η προσωπική μου υλοποίηση της Δευτερης Άσκησης.

Στα ηδη υπάρχοντα αρχεια απο την πρωτη ασκηση προστεθηκαν αλλα δυο τα list και τα tree.

Το list αρχειο περιεχει δυο κλασεις την Listnode και την List.

H Listnode εχει στο private κομματι εναν δεικτη σε Post και εναν δεικτη στον επομενο κομβο της λιστας.
Επιλεχθηκε να εχει δεικτη σε Post και οχι το ιδιο το ποστ η ενα αντιγραφο αυτου γιατι 
καλλουταν ο constuctor του Post. Eιναι κλαση αρα δεδομενα κρυφα απο το υπολοιπο προγραμμα , και συναρτησεις
γνωστες. Οι συναρτησεις ειναι της μιας γραμμης , απλες και κανουν αυτο που λεει το ονομα τους.

Επειτα εχουμε την List. Aυτη η κλαση εχει σαν δεδομενα εναν δεικτη στο πρωτο στοιχειο της λιστας και 
εναν μετρητη που δειχνει το μεγεθος της λιστας. Η συναρτηση ListUnite εφαρμοζεται πανω σε ενα αντικειμενο τυπου 
List και λαμβανοντας ως δεδομενο εναν δεικτη σε μια αλλη λιστα ενωνει τις δυο λιστες.

Το αλλο αρχειο αυτο του tree εχει μια κλαση , την Τree.

H Tree εχει στα δεδομενα ενα δεικτη σε μια λιστα απο Post , δυο δεικτες σε Tree (δεξι κ αριστερο παιδι) και εναν μετρητη
counter που δειχνει τον συνολικο αριθμο ποστ που εχει ο συγκεκριμενος κομβος του δεντρου.

Οι συναρτησεις για τη δημιουργια ενος δεντρου απο ενα Thread ειναι οι tree_create και οι tree_imput.
H tree create εχει ως ορισμα ενα Thread και καλει για καθε ποστ του θρεντ την tree imput η οποια αναδρομικα βρισκει 
την σωστη θεση του ποστ στο δεντρο . Επειτα η tree create επιστρεφει τον δεικτη που δειχνει στη ριζα του δεντρου που 
φτιαχτηκε με τα ποστ. Στην ουσια η tree create ειναι ενας constructor

Oι συναρτησεις Tree marriage και tree_node_to_tree εχουν να κανουν με την εννοποιηση δεντρων

Η tree marriage εφαρμοζεται πανω σε ενα δεντρο( ας το πουμε Δ1) και εχει ως δεδομενο ενα δεικτη σε ενα αλλο
δεντρο (Δ2) . Αυτο που κανει ειναι να επισκεπτεται ολους τους κομβους του Δ1 με inorder σειρα και για τον καθενα απο
αυτους να εφαρμοζει την tree_node_to_tree με δεδομενο το Δ2

Η tree_node_to_tree εφαρμοζεται πανω σε ενα κομβο του Δ1 και με δεδομενο τον δεικτη σε δεντρο Δ2
 βρισκει την θεση του στο Δ2. Αν υπαρχει ιδιος κομβος στο Δ2 ενωνονται οι λιστες των ποστ
 και αθροιζονται οι μετρητες .Αν δεν υπαρχει δημιουργειται και παιρνει τα ιδια δεδομενα με τον κομβο του Δ1.

Στην ουσια η tree_node_to_tree ειναι ιδια με την tree imput απλα αντι για ενα ποστ , εχει ως ορισμα ενα κομβο δεντρου.

Στην συνεχεια παμε στις συναρτησεις ~Tree και tree_destroy οι οποιες ειναι υπευθυνες για την απελευθερωση ολων αυτων 
των δεδομενων που εχουν δεσμευτει δυναμικα. Oταν στο προγραμμα θελουμε να διαγραψουμε ενα δεντρο καλουμε την tree destroy
οι οποια ειναι αναδρομικη και αυτη στο τελος καλει τον destructor ~Tree

H print sorted φτιαχνει οσα δεντρα ειναι και τα θρεντ και μετα τα ενωνει ολα στο πρωτο δεντρο που αρχικοποιηθηκε με το
πρωτο θρεντ.

Γενικα με τα δεντρα δουλευω με δεικτες σε αντικειμενα  και οχι με αντικειμενα αυτα καθε αυτα. Αυτο γενικα 
εμενα με βοηθησε να κανω πολυ απλες υλοποιησεις. Οταν αρχισα να φτιαχνω τον destructor ειχα θεματα και ειδα οτι χρειαζομαι
δυο συναρτησεις τελικα για να κανω σωστη αποδεσμευση των δεδομενων, κατι που δεν νομιζω να ειναι παρα πολυ θεμιτο.
Για μενα ο τροπος που σχεδιασα το προγραμμα ειναι αντικειμνοστραφης γιατι τα δεδομενα ειναι κρυφα και μονο οι συναρτησεις 
γνωστες που απο οτι εχω καταλαβει απο τα μαθηματα της κ.Ιζαμπο αυτο ειναι η βαση του αντικειμνοστραφη. 

Το προγραμμα τρεχει κομπλε.

Εντολη μεταγλωττισης make.